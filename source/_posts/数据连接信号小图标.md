---
title: 数据连接信号小图标
date: 2018-03-08 11:21:55
tags:
---
### 1.数据连接信号图标，就是指在 联网时，出现的E，3G，H+等图标，它们是属于DataType，
DataType.java (frameworks\base\packages\systemui\ext\src\com\mediatek\systemui\ext)
这些图标就是标识不同的网络连接类型。。至于它们各自的区别，那是属于技术标准的问题。
比如 ： 他们的理论速度之类的都是不同的。。
2G－－－－－GSM，速率9Kbps
2.5G－－－－GPRS，速率115Kbps
2.7G－－－－EDGE 速率384Kbps
3G－－－－－WCDMA 速率384Kbps
3.5G－－－－HSDPA 速率3.6M
4G－－－－－WIMAX 速率更高

### 2.另一种，有时候出现的2G，3G之类的，那是属于 NetworkType
NetworkType.java (frameworks\base\packages\systemui\ext\src\com\mediatek\systemui\ext)
即注册的是2G还是3G网络，联通定制会显示单独的网络图标，这两者是不同的。。

### 3.那些数据连接信号图片的图片资源位于 frameworks/base/packages/SystemUI/res/drawable-*dpi/下面。
  并且他们根据是否漫游(roaming)有两种图标，并且每种类型共计有五种颜色。


### 4.SystemUI上面，那些蓝牙，wifi，电池，信号强度，数据连接信号等这些小图标，并不是在java代码当中new出来的，而就是普通的布局，不过使用了include等形式，所以布局的比较复杂，然后在java代码当中，来控制它们是否显示。

### 5.对于 单双卡情况来讲，如果有必要，双卡情况使用的文件名都有gemini后缀。
而对于数据连接小图标相关显示，以及更新情况，就集中在两个java文件中。
其中 单卡会走networkcontroller.java和signalclusterview.java,双卡会跑networkcontrollergemini.java和signalclusterviewgemini.java 


### 6.确定每张卡是卡一，还是卡二，以及每张卡的颜色（同时来决定显示不同颜色的小图标），都是通过SIMHelper 来得到的。他们的颜色，卡号都是与settigns下面的SIM卡管理中一致的。

### 7.对于数据连接，他们的布局文件是在 Gemini_signal_cluster_view.xml (frameworks\base\packages\systemui\res\layout)。
``` xml
<ImageView
    android:id="@+id/data_type"
    android:layout_height="wrap_content"
    android:layout_width="wrap_content" />
```

并且通过这里的布局其实也可以看到，布局当中是准备了四张卡的情况的。。

### 8.有了布局，在代码当中  SignalClusterView.java (frameworks\base\packages\systemui\src\com\android\systemui\statusbar)
中 mDataType[i]                  = (ImageView) findViewById(R.id.data_type);
创建了具体对象。。然后通过不同情况，来控制其显示还是消失。
mDataType[i].setVisibility((!mWifiVisible) ? View.VISIBLE: View.GONE);
 
而该布局对象的资源id。是通过 mDataType[i].setImageDrawable(mMobileTypeId[i].getDrawable());来设置的。。
而这个设置具体的资源所有的apply（）方法，在任意一个小图标状态发生改变时，都会被调用

而 mMobileTypeId[i]这个值，是在 
setMobileDataIndicators(......)方法中
mMobileTypeId[slotId] = typeIcon.clone();
得到。
注意这个 clone方法。在这块内容当中，很多资源关联的对象，都是使用了 
public class IconIdWrapper implements Cloneable
类，这种类实现 Cloneable接口，然后具体对象可以通过clone（）方法，来克隆该对象在内存中的一份拷贝。而不会修改其本身的内容。。
IconIdWrapper.java (frameworks\base\packages\systemui\ext\src\com\mediatek\systemui\ext)	

### 9.而 setMobileDataIndicators（）方法则是在 networkcontroller.java中被调用，并且通过快递参数来设置不同的资源。。

```
在 NetworkController.java (frameworks\base\packages\systemui\src\com\android\systemui\statusbar\policy)	中
public void  refreshSignalCluster()中，调用
cluster.setMobileDataIndicators(
    i,
    mHasMobileDataFeature,
    mPhoneSignalIconId[i],
    mMobileActivityIconId[i],
    mDataTypeIconId[i],                              //yaowen0209
    mContentDescriptionPhoneSignal[i],
    mContentDescriptionDataType[i]);
}
```

而 mDataTypeIconId[] 的值 是在 updateDataNetType（）方法中来设置的
具体的代码流程如下：
mDataTypeIconId[slotId] = tempDataTypeIconId.clone();
而 tempDataTypeIconId则是在该方法中，根据不同情况，通过 下面的形式来得到的
tempDataTypeIconId.setResources(null);
tempDataTypeIconId.setIconId(iconList[simColorId]);
或
tempDataTypeIconId.setResources(PluginFactory.getStatusBarPlugin(mContext).getPluginResources());
tempDataTypeIconId.setIconId(iconList[simColorId]);
所以最后这个值，是通过iconList 来进行最终的传递和设定的。而iconList是通过一个工厂方法，结合漫游和不同的数据连接类型来得到的。
int[] iconList = PluginFactory.getStatusBarPlugin(mContext).getDataTypeIconListGemini(tempIsRoaming, tempDateType);
而 tempDateType就是各种case的中，进行的赋值。。
比如  
case TelephonyManager.NETWORK_TYPE_UMTS:
case TelephonyManager.NETWORK_TYPE_HSDPA:
case TelephonyManager.NETWORK_TYPE_CDMA:
等等。
而这些不同分支，最终都是Modem来进行判断上传。。

而这个 来设置不同的图标的过程，有很多种情况都是使那些图标得到更新。。
通过代码可以发现，比如 广播，手机状态监听器，服务状态改变，电话状态改变，数据连接状态改变等都会使他们发生改变

### 10.而最后一个问题就是，再代码中，根据不同情况，来设置显示不同的数据连接小图标。那么他们是怎么来具体的和那些Drawable资源。来设置的。
实际上，代码中将相关资源都定义在了同一个文件中，
``` Java
TelephonyIcons.java (frameworks\base\packages\systemui\src\com\android\systemui\statusbar\policy)
比如 
static final int[] NETWORK_TYPE_G = {
    R.drawable.stat_sys_gemini_signal_g_blue,
    R.drawable.stat_sys_gemini_signal_g_orange,
    R.drawable.stat_sys_gemini_signal_g_green,
    R.drawable.stat_sys_gemini_signal_g_purple,
    R.drawable.stat_sys_gemini_signal_g_blue
};
```
	
然后通过公开接口，以供调用。。
比如：
``` Java
public static int[] getDataTypeIconListGemini(boolean roaming, DataType dataType) {
    int[] iconList = null;
    if (roaming) {
        iconList = DATA_ROAM[dataType.getTypeId()];
    } else {
        iconList = DATA[dataType.getTypeId()];
    }
    return iconList;
}
```
 
而具体调用地方，就是通过 iconList的工厂方法
``` Java
int[] iconList = PluginFactory.getStatusBarPlugin(mContext).getDataTypeIconListGemini(tempIsRoaming, tempDateType);
```
来根据是否漫游，数据连接类型，来得到不同资源ID。






